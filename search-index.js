var searchIndex = {};
searchIndex['ltspice_run'] = {"items":[],"paths":[]};
searchIndex['ltspice_parse'] = {"items":[[3,"SteppedSimulation","ltspice_parse","A set of results of one Stepped Simulation read from a File",null,null],[0,"results","","This module contains all Functions to work with a single Step",null,null],[3,"VariableResult","ltspice_parse::results","This struct contains all data for one result of a simulation step. The data is accessible in different formats",null,null],[3,"SteppingVariable","","This struct contains the name and the value of one param in a step",null,null],[12,"name","","The name of the `.param` parameter",0,null],[12,"value","","The value of the parameter in this step",0,null],[3,"SimulationVariable","","This structure defines a variable on the netlist of the simulation",null,null],[12,"id","","The internal id",1,null],[12,"name","","The string in the netlist",1,null],[12,"var_type","","The type of the variable",1,null],[4,"DataType","","This enum is used to tell the SteppingVariable, which kind of Data it should use in different functions",null,null],[13,"Real","","Take the real part of the complex value",2,null],[13,"Imaginary","","Take the imaginary part of the complex value",2,null],[13,"Absolute","","Take the absolute part of the complex value",2,null],[13,"AbsoluteDecibel","","Take the absolute part of the complex value as decibel (follows: `20*log(abs(x))`)",2,null],[13,"Argument","","Take the argument of the complex value. This is not yet implemented.",2,null],[4,"PeakType","","",null,null],[13,"Minimum","","",3,null],[13,"Maximum","","",3,null],[4,"VariableType","","This enum is used to determine the physical type of the variable",null,null],[13,"Frequency","","",4,null],[13,"Voltage","","",4,null],[13,"Current","","",4,null],[13,"Unknown","","",4,null],[6,"Step","","A step is a list of SteppingVariables",null,null],[11,"clone","","",5,{"inputs":[{"name":"variableresult"}],"output":{"name":"variableresult"}}],[11,"fmt","","",5,{"inputs":[{"name":"variableresult"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new instance of a VariableResult",5,{"inputs":[{"name":"variableresult"},{"name":"simulationvariable"},{"name":"vec"},{"name":"vec"}],"output":{"name":"self"}}],[11,"get_data","","Returns the data as a vector.",5,{"inputs":[{"name":"variableresult"},{"name":"datatype"}],"output":{"name":"vec"}}],[11,"diff","","Calculates a difference vector of your raw data: `d(n) = x(n+1)-x(n)`",5,{"inputs":[{"name":"variableresult"},{"name":"vec"}],"output":{"name":"vec"}}],[11,"find_peaks","","Finds peaks in the data",5,{"inputs":[{"name":"variableresult"},{"name":"option"},{"name":"datatype"}],"output":{"name":"vec"}}],[11,"get_data_point","","Returns a single data point converted to the given data type",5,{"inputs":[{"name":"variableresult"},{"name":"datatype"},{"name":"usize"}],"output":{"name":"option"}}],[11,"len","","Returns the length of the data set",5,{"inputs":[{"name":"variableresult"}],"output":{"name":"usize"}}],[11,"min","","Returns the minimal value in the data set of the given data type",5,null],[11,"max","","Returns the maximal value in the data set of the given data type",5,null],[11,"avg_normalized","","Returns the average of the values in the given data types. This average is normalized so that\nthe logarithmic scaling of the frequency is not present anymore. This method tries to compute the average\nin a way, that it would seem, that the frequency is scaled linearly. ",5,{"inputs":[{"name":"variableresult"},{"name":"datatype"},{"name":"variableresult"}],"output":{"name":"f64"}}],[11,"find_value_near_freq","","Searches the dataset for the first value after the given search frequency. To search for a value near 500 Hz call",5,null],[11,"next_value_around","","Returns the next occurence of a value higher/lower than the value at the starting\npoint plus/minus the offset in both directions",5,null],[11,"calculate_resonance_penalty","","Used for myself. Not really documented",5,{"inputs":[{"name":"variableresult"},{"name":"variableresult"}],"output":{"name":"f64"}}],[11,"calculate_fitness","","Used for myself. Not really documented",5,null],[11,"plot","","Uses GNUplot to plot the Bode plot (just absolute, no phase)",5,{"inputs":[{"name":"variableresult"},{"name":"variableresult"},{"name":"figure"},{"name":"str"},{"name":"str"}],"output":null}],[11,"eq","","",0,{"inputs":[{"name":"steppingvariable"},{"name":"steppingvariable"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"steppingvariable"},{"name":"steppingvariable"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"steppingvariable"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",0,{"inputs":[{"name":"steppingvariable"}],"output":{"name":"steppingvariable"}}],[11,"new","","Creates a new SteppingVariable using the string format, which can be usually found in the `.log` file",0,{"inputs":[{"name":"steppingvariable"},{"name":"str"}],"output":{"name":"self"}}],[11,"eq","","",1,{"inputs":[{"name":"simulationvariable"},{"name":"simulationvariable"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"simulationvariable"},{"name":"simulationvariable"}],"output":{"name":"bool"}}],[11,"hash","","",1,null],[11,"fmt","","",1,{"inputs":[{"name":"simulationvariable"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",4,{"inputs":[{"name":"variabletype"},{"name":"variabletype"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"variabletype"},{"name":"variabletype"}],"output":{"name":"bool"}}],[11,"hash","","",4,null],[11,"fmt","","",4,{"inputs":[{"name":"variabletype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","ltspice_parse","",6,{"inputs":[{"name":"steppedsimulation"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_files","","Reads the Simulation result form the `.raw`-File. This also needs the\n`.log`-File to get informations about the steps.",6,{"inputs":[{"name":"steppedsimulation"},{"name":"p"},{"name":"p"}],"output":{"name":"self"}}],[11,"available_parameters","","Returns a vector with all `.param` parameters as strings.",6,{"inputs":[{"name":"steppedsimulation"}],"output":{"name":"vec"}}],[11,"available_variables","","Returns a vector of all available variables which resulted of the simulation",6,{"inputs":[{"name":"steppedsimulation"}],"output":{"name":"vec"}}],[11,"get_variable_for_name","","Returns a variable, which has the given name. If no variable for that name can be found, it returns None",6,{"inputs":[{"name":"steppedsimulation"},{"name":"str"}],"output":{"name":"option"}}],[11,"available_steps","","Returns a vector of all steps of the simulation",6,{"inputs":[{"name":"steppedsimulation"}],"output":{"name":"vec"}}],[11,"get_values_at","","Returns all VariableResults for one step",6,{"inputs":[{"name":"steppedsimulation"},{"name":"step"}],"output":{"name":"vec"}}],[11,"get_values_for_variable_at","","Returns the VariableResult for one variable at a given step",6,{"inputs":[{"name":"steppedsimulation"},{"name":"step"},{"name":"simulationvariable"}],"output":{"name":"option"}}],[11,"calculate_fitnesses","","Calculates the fitnesses of all steps for a given variable.\nThe fitness is determined by the internal fitness function of the VariableResult.\nCurrently it is not possible to define the fitness function by yourself.",6,{"inputs":[{"name":"steppedsimulation"},{"name":"simulationvariable"}],"output":{"name":"vec"}}],[11,"find_averages_for_fitness","","",6,null],[11,"find_with_resonance_at","","Finds all VariableResults, that contain a resonance at the given frequency.\nThis algorithm is not very good at the current moment, as it just takes the frequency ticks with a distance of 2\nto determine the borders of the allowed frame.",6,{"inputs":[{"name":"steppedsimulation"},{"name":"simulationvariable"},{"name":"f64"}],"output":{"name":"vec"}}]],"paths":[[3,"SteppingVariable"],[3,"SimulationVariable"],[4,"DataType"],[4,"PeakType"],[4,"VariableType"],[3,"VariableResult"],[3,"SteppedSimulation"]]};
searchIndex['rust_ltspice_parser'] = {"items":[],"paths":[]};
initSearch(searchIndex);
